from sklearn.utils.extmath import stable_cumsum
from sklearn_extra.cluster import KMedoids
import numpy as np

"""
classLocalSearch which extends the KMedoids class from the sklearn_extra.cluster module. 
This class  has some additional initialization parameters and overrides the _kpp_init method of the KMedoids class.

The _kpp_init method is a helper function for initializing the medoids in the k-medoids clustering algorithm. 
It uses a method similar to k-means++ to choose initial seeds for the medoids. 


Best_medoids is an optional parameter of the classLocalSearch class that allows you to specify the initial medoids 
to be used for K-medoid clustering initialization. 
If the parameter is passed, the algorithm will use the specified medoids for initialization, 
otherwise it will use a default initialization method.

The best_medoids parameter is used in the _kpp_init method to initialize the medoids with the specified values. 
Specifically, after setting the number of local seeding attempts, the method initializes the centers
with the best medoids (best_medoids.copy()), that means that after setting the number of local seeding attempts, 
the K-Medoids clustering method randomly selects a set of initial centers. 
Then, instead of using these random centers to start the clustering algorithm, the method replaces the initial centers
with the best medoids, which are the points in the dataset that minimize the sum of the distances to the other points 
in the cluster.
 
The algorithm goes on calculating the list of closest distances and the current 
potential for each cluster (Error Sum of Squares or SSE).
It then internally updates each cluster using the specified medoids as a starting point.

In this way, best_medoids provides an initial solution to the clustering problem, which can lead to faster convergence 
and a better final solution
"""

class KMeoids_localsearch(KMedoids):

    def __init__(
            self,
            n_clusters=8,
            metric="manhattan",
            method="alternate",
            init="heuristic",
            best_medoids=None,
            max_iter=300,
            random_state=None,
    ):
        self.n_clusters = n_clusters
        self.metric = metric
        self.method = method
        self.init = init
        self.max_iter = max_iter
        self.random_state = random_state
        self.best_medoids = best_medoids


    def _kpp_init(self, D, n_clusters, random_state_, n_local_trials=None):
        """Init n_clusters seeds with a method similar to k-means++

        Parameters
        -----------
        D : array, shape (n_points, n_points)
            The distance matrix we will use to select medoid indices.

        n_clusters : integer
            The number of seeds to choose

        random_state : RandomState
            The generator used to initialize the centers.

        Legend
        -----
        > D: an array of shape (n_points, n_points) representing the distance matrix used to select medoid indices.
        > n_clusters: an integer representing the number of seeds to choose.
        > random_state_: an instance of the RandomState class used to initialize the centers.
        > n_points: an integer representing the number of points in the dataset.
        > closest_dist_sq: an array of shape (n_points,) representing the squared distances between each sample and
            its nearest center.
        > current_pot: a float representing the current potential of the cluster.
        > i: an integer representing the current iteration index of the for loop over the centers.
        > center_id: an integer representing the index of the current center being processed.
        > distances: an array of shape (n_points,) representing the distances between the current center and all the
            samples in the dataset.
        > closest_dist_sq_i: an array of shape (n_points,) representing the squared distances between each sample and
            its nearest center in the current iteration.
        > current_pot_i: a float representing the potential of the current center in the current iteration.
        > cluster_indices: a boolean array of shape (n_points,) representing whether each sample belongs to the current
            cluster being processed.
        > cluster_distances: an array of shape (n_cluster_samples, n_cluster_samples) representing the distances between
            all pairs of samples in the current cluster being processed.
        > cluster_pot: a float representing the potential of the current cluster being processed.
        > candidate_ids: an array of shape (n_cluster_samples,) representing the indices of the candidate samples to be
            chosen as the new center.
        > rand_vals: a float representing a random value generated by random_state_ used to select a candidate sample.
        > candidate_index: an integer representing the index of the chosen candidate sample in candidate_ids.
        > candidate_id: an integer representing the index of the chosen candidate sample in the dataset.
        > new_pot: a float representing the potential of the current cluster if the current center is replaced by
            the candidate sample.
        """
        n_points, _ = D.shape

        centers = np.empty(n_clusters, dtype=int)

        # Initialize with best medoids
        centers = self.best_medoids.copy()

        # Initialize medoids with those found previously.

        # Initialize list of closest distances and calculate current potential for each cluster
        closest_dist_sq = np.zeros((n_points,))
        current_pot = 0

        # Initialize the list of nearest samples for each point, and calculate the current potential for each cluster.
        for i, center_id in enumerate(centers):
            distances = D[center_id, :]  # Distances from center_id
            closest_dist_sq_i = distances ** 2
            current_pot_i = closest_dist_sq_i.sum()
            closest_dist_sq[distances < closest_dist_sq_i] = distances[distances < closest_dist_sq_i] ** 2
            current_pot += current_pot_i

            # For each initialized centroid, it calculates the list of samples from the centroid to each point and the
            # list of the nearest samples.
            # It also updates the cluster potential with the sum of the squared samples of the nearest points.

        # Update each cluster internally
        """
        In this for loop, center_index is used as the cluster index, while center_id is used as the index of the medoid 
        corresponding to the cluster. Specifically, center_index is used to indicate the cluster that is created around 
        the medoid center_id. 
        In other words, center_index represents the number of the corresponding cluster, 
        while center_id represents the index of the medoid (i.e., the corresponding row in the X array) 
        that is used to define the center of the cluster.
        In summary, center_index is used to denote the cluster, while center_id is used to denote the medoid 
        that represents the center of the corresponding cluster.
        """
        for center_index, center_id in enumerate(centers):
            cluster_indices = (labels == center_index)
            cluster_distances = D[cluster_indices][:, cluster_indices]
            cluster_pot = (cluster_distances ** 2).sum()
            candidate_ids = np.arange(n_points)[cluster_indices]
            n_local_trials = max(int(2 * np.log(n_clusters)) ** 2, 1)

            # For each cluster, the internal update phase begins.
            #Initializes the index of points in the cluster, the samples between points, and the cluster potential.

            for trial in range(n_local_trials):
                rand_vals = random_state_.random_sample() * cluster_pot
                candidate_index = np.searchsorted(np.cumsum(cluster_distances.sum(axis=1)), rand_vals)
                candidate_id = candidate_ids[candidate_index]
                new_pot = ((D[candidate_id, cluster_indices]) ** 2).sum()

                """
                For each internal update attempt, randomly choose a point in the clusterand calculate the new distance 
                to the centroid if it were replaced by the chosen point.
                If the cluster potential decreases, replace the centroid with the chosen point and update
                the samples between the points.
                """

                if new_pot < cluster_pot:
                    centers[center_index] = candidate_id
                    cluster_distances[candidate_index] = D[candidate_id, cluster_indices]
                    cluster_distances[:, candidate_index] = D[cluster_indices, candidate_id]
                    cluster_pot = new_pot

        # Return new cluster centers updated internally.
        return centers

